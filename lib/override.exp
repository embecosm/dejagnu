# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
# 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
#
# This file is part of DejaGnu.
#
# DejaGnu is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# DejaGnu is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with DejaGnu; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.

# This file was written by Edward Jones <ed.jones@embecosm.com>.


# Marks whether a manifest has been read in
set override_manifest_loaded 0

# Maps a test name to a list of manifest entries. Each entry is a list of
# the form:
#   new_result [flags_pattern [subtests_pattern [line_num]]]
set override_dict ""


# Initialize the override manifest, this then allows the testsuite to query the
# test manifest and check if a given test has been overridden.
proc init_override_manifest { } {
    global override_manifest_loaded
    global override_manifest
    global override_dict

    # ignore if no manifest present
    if { ![info exists override_manifest] || $override_manifest == ""} {
	verbose "No override manifest specified"
	return
    }
    if { $override_manifest_loaded == 1 } {
	verbose "Manifest already loaded"
	return
    }
    # Only load in the manifest if it's not already loaded
    verbose "Initializing override manifest $override_manifest"
    set override_dict [load_override_manifest $override_manifest]
    set override_manifest_loaded 1
}

# Uninitialize the override manifest. This allows another manifest to be
# loaded.
proc finish_override_manifest { } {
    global override_manifest_loaded
    global override_dict

    if { $override_manifest_loaded == 0 } {
	return
    }
    verbose "Uninitializing override manifest"
    set override_manifest_loaded 0
    set override_dict ""
}

proc read_manifest_line { manifest_line } {
    # The expected result - e.g. "FAIL:", "PASS:", etc.
    set expected "^(\\S+):"
    # Optional patterns to match the test name, flags, subtest and line number
    # in the form [field]
    set optional "(\\s+(\\\[\[^\\\]\]*\\\]))?"
    set optionals "${optional}${optional}${optional}${optional}"
    # Pattern for the remainder of the line (which should be a comment)
    set remainder "(\\s+(.*))?"
    # The whole line
    set manifest_line_pattern "${expected}${optionals}${remainder}"

    set match [regexp $manifest_line_pattern $manifest_line x new_result test_name x flags x subtest x line_num x remainder]

    set result [dict create match $match]
    if { $match == 0 } {
        override_log "Malformed line in manifest -> $manifest_line"
        return $result
    }

    dict set result new_result [string trim $new_result]
    dict set result test_name [string trim $test_name]
    dict set result flags [string trim $flags]
    dict set result subtest [string trim $subtest]
    dict set result line_num [string trim $line_num]
    dict set result remainder [string trim $remainder]
    return $result
}

# Load in an override manifest from the provided file
proc load_override_manifest { manifest_file } {
    verbose "Loading override manifest $manifest_file"

    set fp [open $manifest_file r]
    set file_data [read $fp]
    close $fp
    set manifest_data [split $file_data "\n"]
    set override_dict [read_override_manifest $manifest_data]
    return $override_dict
}

proc read_override_manifest { manifest_data } {
    set override_dict ""

    foreach orig_line $manifest_data {
	# trim the line down
	set new_line [string trim $orig_line]

	# If the first character is a '#' or the line is empty, ignore it
	if { $new_line == "" || [string index $new_line 0] == "#" } {
	    continue
	}

	# Read the test name, the new expected result and the optional flag,
	# subtest and line number fields.
        set override [read_manifest_line $new_line]
        set match [dict get $override match]
        set new_result [dict get $override new_result]
        set test_name [dict get $override test_name]
        set flags [dict get $override flags]
        set subtest [dict get $override subtest]
        set line_num [dict get $override line_num]
        set remainder [dict get $override remainder]

        if { $match == 0 } {
	    return ""
	}

        if { [string length $test_name] >= 2 } {
            set test_name [string range $test_name 1 [expr [string length $test_name] - 2]]
            set test_name [string trim $test_name]
        }

        if { [string length $flags] >= 2 } {
            set flags [string range $flags 1 [expr [string length $flags] - 2]]
            set flags [string trim $flags]
        }

        if { [string length $subtest] >= 2 } {
            set subtest [string range $subtest 1 [expr [string length $subtest] - 2]]
            set subtest [string trim $subtest]
        }

        if { [string length $line_num] >= 2 } {
            set line_num [string range $line_num 1 [expr [string length $line_num] - 2]]
            set line_num [string trim $line_num]
        }

	# The end of the line should either be empty, or begin with a comment
	# character.
        set remainder [string trim $remainder]
	if { $remainder != "" } {
	    if { [string index $remainder 0] != "#" } {
		override_log "Trailing characters in line -> $orig_line"
		return ""
	    }
	}

        # We can't have a completely wild set of values for the test.
        # (Also line number only is not allowed, because that makes
        # very little sense)
        if { $test_name == "" && $flags == "" && $subtest == "" } {
            override_log "Can't have wildcard name, test, and flags"
            return ""
        }

	# check that the new result is a valid value
        switch $new_result {
	    "PASS" { }
	    "XFAIL" { }
	    "UNSUPPORTED" { }
	    default {
		override_log "Invalid result in line -> $new_result"
		return ""
	    }
	}

	# Create an entry and add it to the dictionary
        set key "$test_name,$flags,$subtest,$line_num"
        dict set override_dict $key $new_result
    }

    # Return the loaded dictionary
    return $override_dict
}

# Query the override manifest, returning the new expected result for a given
# test.
#
# test_name  The name of the file being tested
# flags      Optional flags this test is being run with.
# subtest    Optional subtest which is being executed
# line_num   Optional line number the subtest occurs on
#
# Return the new expected result for the test
proc query_override { test_name flags subtest line_num } {
    # This global is used to set/clear an xfail on a test
    global compiler_conditional_xfail_data
    global override_manifest_loaded
    global override_dict

    # No override manifest yet, load one
    if { $override_manifest_loaded != 1 } {
	init_override_manifest
    }

    # Trim down all of the input arguments
    set test_name [string trim $test_name]
    set flags     [string trim $flags]
    set subtest   [string trim $subtest]
    set line_num  [string trim $line_num]

    set keys {}
    lappend keys "$test_name,$flags,$subtest,$line_num"
    lappend keys "$test_name,$flags,$subtest,"
    lappend keys "$test_name,$flags,,$line_num"
    lappend keys "$test_name,$flags,,"
    lappend keys "$test_name,,$subtest,$line_num"
    lappend keys "$test_name,,$subtest,"
    lappend keys "$test_name,,,$line_num"
    lappend keys "$test_name,,,"

    foreach key $keys {
        if { [dict exists $override_dict $key] } {
            return [dict get $override_dict $key ]
        }
    }

    # Nothing found - must be absent
    return "ABSENT"
}


# Query the override manifest and handle the override by setting/clearing
# xfail, or by marking the test as unsupported.
#
# log_str    The string that would normally have been printed out to the
#            test log
# test_name  The name of the file being tested
# flags      Optional flags this test is being run with.
# subtest    Optional subtest which is being executed
# line_num   Optional line number the subtest occurs on
#
# Return 1 if the test is unsupported and therefore should not be run, otherwise
# return 0
proc handle_override { log_str test_name flags subtest line_num } {
    global compiler_conditional_xfail_data
    
    set new_result [query_override $test_name $flags $subtest $line_num]
    switch $new_result {
	"PASS" {
	    override_log "$log_str now expected to pass"
	    if {[info exists compiler_conditional_xfail_data]} {
		unset compiler_conditional_xfail_data
	    }
	    clear_xfail "*-*-*"
	}
	"XFAIL" {
	    override_log "$log_str now expected to fail"
	    setup_xfail "*-*-*"
	}
	"UNSUPPORTED" {
	    override_log "$log_str now unsupported, skipping it"
	    unsupported "$log_str"
	    return 1
	}
	default { } # do nothing if it's absent
    }
    # By default do nothing
    return 0
}


# Log that an override has taken place.
proc override_log { message } {
    send_user "OVERRIDE: ${message}\n"
}

