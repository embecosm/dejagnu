# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
# 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
#
# This file is part of DejaGnu.
#
# DejaGnu is free software; you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# DejaGnu is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with DejaGnu; if not, write to the Free Software Foundation,
# Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.

# This file was written by Edward Jones <ed.jones@embecosm.com>.


# Marks whether a manifest has been read in
set override_manifest_loaded 0

# Maps a test name to a list of manifest entries. Each entry is a list of
# the form:
#   new_result [flags_pattern [subtests_pattern [line_num]]]
set override_dict ""


# Initialize the override manifest, this then allows the testsuite to query the
# test manifest and check if a given test has been overridden.
proc init_override_manifest { } {
    global override_manifest_loaded
    global override_manifest
    global override_dict

    # ignore if no manifest present
    if { ![info exists override_manifest] || $override_manifest == ""} {
	verbose "No override manifest specified"
	return
    }
    if { $override_manifest_loaded == 1 } {
	verbose "Manifest already loaded"
	return
    }
    # Only load in the manifest if it's not already loaded
    verbose "Initializing override manifest $override_manifest"
    set override_dict [load_override_manifest $override_manifest]
    set override_manifest_loaded 1
}

# Uninitialize the override manifest. This allows another manifest to be
# loaded.
proc finish_override_manifest { } {
    global override_manifest_loaded
    global override_dict

    if { $override_manifest_loaded == 0 } {
	return
    }
    verbose "Uninitializing override manifest"
    set override_manifest_loaded 0
    set override_dict ""
}

proc read_manifest_line { manifest_line } {
    # The expected result - e.g. "FAIL:", "PASS:", etc.
    set expected "^(\\S+):"
    # The test name follows, separated from the expected result by whitespace
    set test_name "\\s+(\\S+)"
    # Optional patterns to match the flags, subtest and line number in the
    # form [field]
    set optional "(\\s+(\\\[\[^\\\]\]*\\\]))?"
    set optionals "${optional}${optional}${optional}"
    # Pattern for the remainder of the line (which should be a comment)
    set remainder "(\\s+(.*))?"
    # The whole line
    set manifest_line_pattern "${expected}${test_name}${optionals}${remainder}"

    set match [regexp $manifest_line_pattern $manifest_line x new_result test_name x flags x subtest x line_num remainder]

    set result [dict create match $match]
    if { $match == 0 } {
        override_log "Malformed line in manifest -> $manifest_line"
        return $result
    }

    dict set result new_result $new_result
    dict set result test_name $test_name
    dict set result flags $flags
    dict set result subtest $subtest
    dict set result line_num $line_num
    dict set result remainder $remainder
    return $result
}

# Load in an override manifest from the provided file
proc load_override_manifest { manifest_file } {
    verbose "Loading override manifest $manifest_file"

    set fp [open $manifest_file r]
    set file_data [read $fp]
    close $fp
    set manifest_data [split $file_data "\n"]
    set override_dict [read_override_manifest $manifest_data]
    return $override_dict
}

proc read_override_manifest { manifest_data } {
    set override_dict ""

    foreach orig_line $manifest_data {
	# trim the line down
	set new_line [string trim $orig_line]

	# If the first character is a '#' or the line is empty, ignore it
	if { $new_line == "" || [string index $new_line 0] == "#" } {
	    continue
	}

	# Read the test name, the new expected result and the optional flag,
	# subtest and line number fields.
        set override [read_manifest_line $new_line]
        set match [dict get $override match]
        set new_result [dict get $override new_result]
        set test_name [dict get $override test_name]
        set flags [dict get $override flags]
        set subtest [dict get $override subtest]
        set line_num [dict get $override line_num]
        set remainder [dict get $override remainder]

        if { $match == 0 } {
	    return ""
	}

	# Empty fields aren't allowed
	if { [string length $flags] >= 2 } {
	    set flags [string range $flags 1 [expr [string length $flags] - 2]]
	    set flags [string trim $flags]
	    if { $flags == "" } {
		override_log "Empty flag field in line -> $orig_line"
		return ""
	    }
	}
	if { [string length $subtest] >= 2 } {
	    set flags [string range $subtest 1 [expr [string length $subtest] - 1]]
	    set flags [string trim $subtest]
	    if { $subtest == "" } {
		override_log "Empty subtest field in line -> $orig_line"
		return ""
	    }
	}
	if { [string length $line_num] >= 2 } {
	    set line_num [string range $line_num 1 [expr [string length $line_num] - 1]]
	    set line_num [string trim $line_num]
	    if { $line_num == "" } {
		override_log "Empty line number field in line -> $orig_line"
		return ""
	    }
	}
	set remainder [string trim $remainder]

	# The end of the line should either be empty, or begin with a comment
	# character.
	set remainder ""
	if { $remainder != "" } {
	    if { [string index $remainder 0] != "#" } {
		override_log "Malformed entry $orig_line"
		return ""
	    }
	}

	# check that the new result is a valid value
	switch $new_result {
	    "PASS" { }
	    "XFAIL" { }
	    "UNSUPPORTED" { }
	    default {
		override_log "Manifest contains an invalid result $new_result"
		return ""
	    }
	}

	# Add this entry to the dictionary
	set entry [list $new_result]
	if { [dict exists $override_dict $test_name] == 1 } {
	    set entries [dict get $override_dict $test_name]
	    lappend entries $entry
	    dict set override_dict $test_name $entries
	} else {
	    set entries [list $entry]
	    dict set override_dict $test_name $entries
	}
    }
    # Return the loaded dictionary
    return $override_dict
}

# Sort the input list of lists by the length of the sublists
proc lsort_by_len { args } {
    set tmp {}
    foreach element $args {
	lappend tmp [list [llength $element] $element]
    }
    set res {}
    foreach i [lsort -index 0 $tmp] {
	lappend res [lindex $i 1]
    }
    set res
}

# Query the override manifest, returning the new expected result for a given
# test.
#
# test_name  The name of the file being tested
# flags      Optional flags this test is being run with.
# subtest    Optional subtest which is being executed
# line_num   Optional line number the subtest occurs on
#
# Return the new expected result for the test
proc query_override { test_name flags subtest line_num } {
    # This global is used to set/clear an xfail on a test
    global compiler_conditional_xfail_data
    global override_manifest_loaded
    global override_dict

    # No override manifest yet, load one
    if { $override_manifest_loaded != 1 } {
	init_override_manifest
    }

    # Trim down all of the input arguments
    set test_name [string trim $test_name]
    set flags     [string trim $flags]
    set subtest   [string trim $subtest]
    set line_num  [string trim $line_num]

    # Look up the manifest entries for the given test name. If there's no
    # entry then do nothing
    if { [dict exists $override_dict $test_name] == 1 } {
	set entries [dict get $override_dict $test_name]
    } else {
	return "ABSENT"
    }

    # Each entry for a given test name contains a number of fields.
    #   new_result [flags_regexp [subtests_regexp [line]]]
    #
    # We sort the entries in length order, so that we match more fine-grained
    # entries before coarser ones.
    set sorted_entries [lsort_by_len $entries]

    for {set i 0} {$i < [llength $sorted_entries]} {incr i} {
	set entry [lindex $sorted_entries $i]

	# assume that this entry is a match until proven otherwise
	set match 1
	set new_result [lindex $entry 0]

	# check that the new_result is a valid value
	switch $new_result {
	    "PASS" { }
	    "XFAIL" { }
	    "UNSUPPORTED" { }
	    default {
		# should never reach here
		return "ABSENT"
	    }
	}

	# check if the flag pattern matches
	if { $match == 1 && [llength $entry] > 1 && $flags != "" } {
	    set flags_pattern [lindex $entry 1]

	    # replace runs of whitespace with \S+ in the pattern
	    set flags_pattern [regexp -all -inline "\S+" $flags_pattern]
	    set flags_pattern [join $flags_pattern "\\S+"]

	    # test against the regexp, and use it to update the match
	    set match [regexp $flags_pattern $flags]
	}
	# check the subtest pattern
	if { $match == 1 && [llength $entry] > 2 && $subtest != "" } {
	    set subtest_pattern [lindex $entry 2]

	    # replace runs of whitespace with \S+ in the pattern
	    set subtest_pattern [regexp -all -inline "\S+" $flags_pattern]
	    set subtest_pattern [join $subtest_pattern "\\S+"]

	    # test against the pattern, update match
	    set match [regexp $subtest_pattern $subtest]
	}
	# check the line number if we have one
	if { $match == 1 && [llength $entry] > 3 && $line_num != "" } {
	    if { [lindex $entry 3] != $line_num } {
		set match 0
	    }
	}

	if { $match == 1 } {
	    return $new_result
	}
    }
    # By default do nothing
    return "ABSENT"
}


# Query the override manifest and handle the override by setting/clearing
# xfail, or by marking the test as unsupported.
#
# log_str    The string that would normally have been printed out to the
#            test log
# test_name  The name of the file being tested
# flags      Optional flags this test is being run with.
# subtest    Optional subtest which is being executed
# line_num   Optional line number the subtest occurs on
#
# Return 1 if the test is unsupported and therefore should not be run, otherwise
# return 0
proc handle_override { log_str test_name flags subtest line_num } {
    global compiler_conditional_xfail_data
    
    set new_result [query_override $test_name $flags $subtest $line_num]
    switch $new_result {
	"PASS" {
	    override_log "$log_str now expected to pass"
	    if {[info exists compiler_conditional_xfail_data]} {
		unset compiler_conditional_xfail_data
	    }
	    clear_xfail "*-*-*"
	}
	"XFAIL" {
	    override_log "$log_str now expected to fail"
	    setup_xfail "*-*-*"
	}
	"UNSUPPORTED" {
	    override_log "$log_str now unsupported, skipping it"
	    unsupported "$log_str"
	    return 1
	}
	default { } # do nothing if it's absent
    }
    # By default do nothing
    return 0
}


# Log that an override has taken place.
proc override_log { message } {
    send_user "OVERRIDE: ${message}\n"
}

